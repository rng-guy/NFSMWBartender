<!-- 
    HERE BE DRAGONS: Genuinely the WORST thing I've ever dared publish.

    I'd rather spend my time reversing game mechanics than refreshing my rusty
    JavaScript knowledge for a one-off tool, so I used Gemini to draft this mess.
    Nonetheless, it still took me hours of manual testing and un-fucking of the styling
    to get this to work as I had envisoned it. I might just rewrite once I get around
    to it, because I low-key loathe myself for having used generative AI for ANYTHING.

    After experiencing the "joys" of "vibecoding" (I hate that word SO much) for myself, 
    let me offer you a small piece of advice: Do NOT use generative AI for anything more
    complicated than basic HTML, CSS, and JS. While functional, this tool is still an 
    unmaintainable, div-laden mess that nobody should EVER attempt to refactor by hand. 
    I cannot even begin to imagine how annoying it would be to unfuck AI-generated C++
    or, god forbid, ASM by hand. My condolences to anyone whose employer mandates AI use.
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NFSMW Bartender: Roadblock Designer</title>
    <style>
        :root { --main-width: 700px; --caption-gap: 5px; }
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; gap: 20px; padding: 20px; background-color: #D9D9DB; }
        .workspace { display: flex; flex-direction: column; width: var(--main-width); gap: 15px; }
        .caption { font-weight: bold; font-size: 20px; color: #444; margin-bottom: var(--caption-gap); }
        .canvas-container { position: relative; width: var(--main-width); }
        #canvasCounter { position: absolute; top: 40px; left: 10px; background: rgba(0,0,0,0.6); color: #fcfcfcfc; padding: 4px 8px; border-radius: 4px; font-size: 11px; pointer-events: none; z-index: 10; }
        #canvasOverlay { position: absolute; bottom: 10px; right: 10px; font-size: 12px; color: #666; pointer-events: none; text-align: right; z-index: 5; }
        canvas { border: none; background-color: #fcfcfcfc; cursor: crosshair; box-shadow: 0 4px 10px rgba(0,0,0,0.1); display: block; width: var(--main-width); outline: none; }
        .bottom-controls { display: flex; justify-content: space-between; align-items: center; width: var(--main-width); margin-bottom: 25px; }
        .btn-group-left, .btn-group-right { display: flex; gap: 10px; }
        button { padding: 10px 15px; cursor: pointer; border-radius: 4px; border: 1px solid #ccc; background: #fcfcfcfc; font-size: 13px; }
        .btn-add { width: 105px; height: 40px; text-align: center; }
	    .btn-misc { height: 40px; text-align: center; }
        button:hover:not(:disabled) { background: #e0e0e0; }
        button:disabled { cursor: not-allowed; opacity: 0.5; background: #ddd; border-color: #ccc; color: #999; }
        .output-container { display: flex; flex-direction: column; width: var(--main-width); }
        .output-wrapper { position: relative; width: var(--main-width); height: 180px; border: 1px solid #999; box-sizing: border-box; }
        #outputField { width: 100%; height: 100%; padding: 10px; border: none; box-sizing: border-box; white-space: pre-wrap; font-family: 'Courier New', monospace; font-size: 12px; overflow-y: auto; cursor: pointer; user-select: none; background: #242426; color: #E5E4E7; }
        #outputOverlay { position: absolute; bottom: 10px; right: 10px; font-size: 12px; color: #999999; pointer-events: none; }
    </style>
</head>
<body>

    <div class="workspace">
        <div class="canvas-container">
            <div class="caption">Roadblock preview</div>
            <div id="canvasCounter">Room for 5 more part(s)</div>
            <div id="canvasOverlay">Left-click to select. Scroll to rotate. Hold Shift to snap.</div>
            <canvas id="mainCanvas" width="700" height="450" tabindex="0"></canvas>
        </div>
        
        <div class="bottom-controls">
            <div class="btn-group-left">
                <button id="btnCar" class="btn-add" onclick="handleAction('car')">✚ car</button>
                <button id="btnSpikes" class="btn-add" onclick="handleAction('spikes')">✚ spikes</button>
                <button id="btnBarricade" class="btn-add" onclick="handleAction('barricade')">✚ barricade</button>
            </div>
            <div class="btn-group-right">
	        <button id="deleteBtn" class="btn-misc" onclick="deleteSelected()" disabled>remove selected</button>
                <button id="btnClear" class="btn-misc" onclick="clearCanvas()">reset</button>
            </div>
        </div>

        <div class="output-container">
            <div class="caption">Bartender settings</div>
            <div class="output-wrapper">
                <div id="outputField"></div>
                <div id="outputOverlay">Click to copy settings.</div>
            </div>
        </div>
    </div>

    <script>
        const IMAGE_RENDER_SCALE = 0.35;
        const LENGTH_SCALE = 4.5 / (340 * IMAGE_RENDER_SCALE);
        const MAX_RECTS = 6;
        const GRID_SIZE = 10;
        const ROT_FINE = 5 * (Math.PI / 180), ROT_COARSE = 10 * (Math.PI / 180);
        const MOVE_FINE = 1, MOVE_COARSE = 10;
        const LAYER_PRIORITY = { barricade: 3, car: 2, spikes: 1 };
        const RECT_CONFIG = {
            car:       { src: 'Assets/Images/car.webp' },
            spikes:    { src: 'Assets/Images/spikes.webp' },
            barricade: { src: 'Assets/Images/barricade.webp' }
        };

        const images = {};
        let imagesLoaded = 0;
        const canvas = document.getElementById('mainCanvas'), ctx = canvas.getContext('2d');
        const outputField = document.getElementById('outputField'), outputOverlay = document.getElementById('outputOverlay'), counterEl = document.getElementById('canvasCounter');
        
        let rects = [], selectedIndices = [], isDraggingGroup = false, isBoxSelecting = false;
        let boxStart = { x: 0, y: 0 }, boxEnd = { x: 0, y: 0 }, dragStartData = null, isShiftDown = false, selectionSnapshot = [], layerCounter = 0, clipboard = null;

        Object.keys(RECT_CONFIG).forEach(key => {
            const img = new Image(); img.src = RECT_CONFIG[key].src;
            img.onload = () => { if (++imagesLoaded === 3) initDefault(); };
            images[key] = img;
        });

        function initDefault() { addRect('car'); draw(); }

        document.addEventListener('mousedown', (e) => {
            if (e.target !== canvas && e.target.tagName !== 'BUTTON' && e.target !== outputField) { selectedIndices = []; updateUI(); draw(); }
        });

        outputField.addEventListener('click', () => {
            navigator.clipboard.writeText(outputField.innerText).then(() => {
                outputOverlay.innerHTML = 'Settings <span style="color: #ffd500">copied</span>.';
                setTimeout(() => { outputOverlay.innerText = "Click to copy settings."; }, 2000);
            });
        });

        window.addEventListener('keydown', (e) => { 
            const isCanvasActive = (document.activeElement === canvas);
            if(e.key === 'Shift') { isShiftDown = true; updateUI(); draw(); }
            if(e.key === 'Delete' || e.key === 'Backspace') deleteSelected();
            if(e.key === 'Escape' && isCanvasActive) { selectedIndices = []; updateUI(); draw(); }
            
            if (e.ctrlKey && e.key.toLowerCase() === 'a' && isCanvasActive) { e.preventDefault(); selectedIndices = rects.map((_, i) => i); updateUI(); draw(); }
            if (e.ctrlKey && e.key.toLowerCase() === 'c' && selectedIndices.length > 0) clipboard = selectedIndices.map(i => ({...rects[i]}));
            if (e.ctrlKey && e.key.toLowerCase() === 'v' && clipboard) {
                if (rects.length + clipboard.length <= MAX_RECTS) {
                    const next = []; clipboard.forEach(c => {
                        layerCounter++; const nr = { ...c, x: c.x + 15, y: c.y + 15, layer: layerCounter };
                        if (!canExistAt(nr, nr.x, nr.y, nr.angle)) { nr.x = canvas.width/2; nr.y = canvas.height/2; }
                        rects.push(nr); next.push(rects.length - 1);
                    });
                    selectedIndices = next; updateUI(); draw();
                }
            }
            
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key) && selectedIndices.length > 0 && isCanvasActive) {
                e.preventDefault();
                const step = isShiftDown ? MOVE_COARSE : MOVE_FINE;
                let limit = step;

                selectedIndices.forEach(idx => {
                    const r = rects[idx], corners = getLocalCorners(r).map(c => ({ x: c.x + r.x, y: c.y + r.y }));
                    if (e.key === 'ArrowUp') limit = Math.min(limit, Math.min(...corners.map(c => c.y)));
                    if (e.key === 'ArrowDown') limit = Math.min(limit, canvas.height - Math.max(...corners.map(c => c.y)));
                    if (e.key === 'ArrowLeft') limit = Math.min(limit, Math.min(...corners.map(c => c.x)));
                    if (e.key === 'ArrowRight') limit = Math.min(limit, canvas.width - Math.max(...corners.map(c => c.x)));
                });

                if (limit > 0) {
                    selectedIndices.forEach(idx => {
                        if (e.key === 'ArrowUp') rects[idx].y -= limit;
                        if (e.key === 'ArrowDown') rects[idx].y += limit;
                        if (e.key === 'ArrowLeft') rects[idx].x -= limit;
                        if (e.key === 'ArrowRight') rects[idx].x += limit;
                    });
                    draw();
                }
            }
        });
        
        window.addEventListener('keyup', (e) => { if(e.key === 'Shift') { isShiftDown = false; updateUI(); draw(); }});
        
        canvas.addEventListener('mousedown', (e) => {
            canvas.focus(); const b = canvas.getBoundingClientRect(), mx = e.clientX - b.left, my = e.clientY - b.top;
            let hitIdx = -1;
            const sorted = rects.map((r, i) => ({r, i})).sort((a, b) => (LAYER_PRIORITY[b.r.type] - LAYER_PRIORITY[a.r.type]) || (b.r.layer - a.r.layer));
            for (let item of sorted) { if (isHit(item.r, mx, my)) { hitIdx = item.i; break; } }

            if (hitIdx !== -1) {
                if (!isShiftDown && !selectedIndices.includes(hitIdx)) selectedIndices = [hitIdx];
                else if (isShiftDown && !selectedIndices.includes(hitIdx)) selectedIndices.push(hitIdx);
                layerCounter++; rects[hitIdx].layer = layerCounter;
                isDraggingGroup = true;
                let minX = Math.min(...selectedIndices.map(i => rects[i].x)), minY = Math.min(...selectedIndices.map(i => rects[i].y));
                dragStartData = { groupMinX: minX, groupMinY: minY, mouseOffsetX: mx - minX, mouseOffsetY: my - minY, itemStarts: selectedIndices.map(idx => ({ idx, x: rects[idx].x, y: rects[idx].y })) };
            } else {
                if (!isShiftDown) selectedIndices = [];
                selectionSnapshot = [...selectedIndices]; isBoxSelecting = true; boxStart = { x: mx, y: my }; boxEnd = { x: mx, y: my };
            }
            updateUI(); draw();
        });

        window.addEventListener('mousemove', (e) => {
            const b = canvas.getBoundingClientRect(), mx = e.clientX - b.left, my = e.clientY - b.top;
            if (isDraggingGroup && dragStartData) {
                let tx = mx - dragStartData.mouseOffsetX, ty = my - dragStartData.mouseOffsetY;
                if (isShiftDown) { tx = Math.round(tx/GRID_SIZE)*GRID_SIZE; ty = Math.round(ty/GRID_SIZE)*GRID_SIZE; }
                const dx = tx - dragStartData.groupMinX, dy = ty - dragStartData.groupMinY;
                const props = dragStartData.itemStarts.map(p => ({ idx: p.idx, x: p.x + dx, y: p.y + dy }));
                let sL = 0, sR = 0, sU = 0, sD = 0;
                props.forEach(p => {
                    const corners = getLocalCorners(rects[p.idx]), minLX = Math.min(...corners.map(c => c.x)), maxLX = Math.max(...corners.map(c => c.x)), minLY = Math.min(...corners.map(c => c.y)), maxLY = Math.max(...corners.map(c => c.y));
                    if (p.x + minLX < 0) sR = Math.max(sR, -(p.x + minLX));
                    if (p.x + maxLX > canvas.width) sL = Math.min(sL, canvas.width - (p.x + maxLX));
                    if (p.y + minLY < 0) sD = Math.max(sD, -(p.y + minLY));
                    if (p.y + maxLY > canvas.height) sU = Math.min(sU, canvas.height - (p.y + maxLY));
                });
                props.forEach(p => { rects[p.idx].x = p.x + sR + sL; rects[p.idx].y = p.y + sD + sU; });
            } else if (isBoxSelecting) {
                boxEnd = { x: mx, y: my }; const xMin = Math.min(boxStart.x, boxEnd.x), xMax = Math.max(boxStart.x, boxEnd.x), yMin = Math.min(boxStart.y, boxEnd.y), yMax = Math.max(boxStart.y, boxEnd.y);
                const inBox = rects.map((r, i) => (r.x >= xMin && r.x <= xMax && r.y >= yMin && r.y <= yMax ? i : -1)).filter(i => i !== -1);
                selectedIndices = Array.from(new Set([...selectionSnapshot, ...inBox])); updateUI();
            }
            draw();
        });

        window.addEventListener('mouseup', () => { isDraggingGroup = false; isBoxSelecting = false; draw(); });

        canvas.addEventListener('wheel', (e) => {
            if (selectedIndices.length > 0) {
                e.preventDefault(); const step = (e.deltaY > 0 ? 1 : -1) * (isShiftDown ? ROT_COARSE : ROT_FINE);
                if (selectedIndices.every(i => canExistAt(rects[i], rects[i].x, rects[i].y, rects[i].angle + step))) { selectedIndices.forEach(i => rects[i].angle += step); draw(); }
            }
        }, { passive: false });

        function canExistAt(r, nx, ny, na) {
            const cos = Math.cos(na), sin = Math.sin(na), hw = r.w/2, hh = r.h/2;
            const corners = [{x:-hw*cos+hh*sin, y:-hw*sin-hh*cos}, {x:hw*cos+hh*sin, y:hw*sin-hh*cos}, {x:hw*cos-hh*sin, y:hw*sin+hh*cos}, {x:-hw*cos-hh*sin, y:-hw*sin+hh*cos}];
            return corners.every(c => (nx + c.x >= 0 && nx + c.x <= canvas.width && ny + c.y >= 0 && ny + c.y <= canvas.height));
        }

        function handleAction(type) {
            if (isShiftDown && selectedIndices.length > 0) {
                const allY = rects.reduce((acc, r, i) => (r.type === 'car' ? acc.concat(i) : acc), []);
                const selY = selectedIndices.filter(i => rects[i].type === 'car');
                const protIdx = (allY.length > 0 && allY.length === selY.length && type !== 'car') ? selY[0] : -1;
                selectedIndices.forEach(idx => { if (idx !== protIdx) transformRect(idx, type); });
            } else addRect(type);
            updateUI(); draw(); canvas.focus();
        }

        function addRect(type) {
            if (rects.length < MAX_RECTS) {
                const img = images[type]; layerCounter++;
                rects.push({ x: canvas.width/2, y: canvas.height/2, w: img.width*IMAGE_RENDER_SCALE, h: img.height*IMAGE_RENDER_SCALE, img, type, angle: 0, layer: layerCounter });
                selectedIndices = [rects.length - 1];
            }
        }

        function transformRect(idx, newType) {
            const r = rects[idx], img = images[newType];
            r.type = newType; r.img = img; r.w = img.width*IMAGE_RENDER_SCALE; r.h = img.height*IMAGE_RENDER_SCALE;
            if (!canExistAt(r, r.x, r.y, r.angle)) { r.x = canvas.width/2; r.y = canvas.height/2; }
        }

        function deleteSelected() {
            if (selectedIndices.length === 0) return;
            const allY = rects.reduce((acc, r, i) => (r.type === 'car' ? acc.concat(i) : acc), []);
            const selY = selectedIndices.filter(i => rects[i].type === 'car');
            let safe = [...selectedIndices].sort((a,b) => b-a);
            if (allY.length > 0 && allY.length === selY.length) safe = safe.filter(i => i !== selY[0]);
            safe.forEach(i => rects.splice(i, 1));
            selectedIndices = rects.length > 0 ? [rects.length - 1] : [];
            updateUI(); draw(); canvas.focus();
        }

        function isHit(r, mx, my) {
            const cos = Math.cos(-r.angle), sin = Math.sin(-r.angle), dx = mx-r.x, dy = my-r.y;
            const rx = dx*cos-dy*sin, ry = dx*sin+dy*cos;
            return (rx >= -r.w/2 && rx <= r.w/2 && ry >= -r.h/2 && ry <= r.h/2);
        }

        function getLocalCorners(r) {
            const cos = Math.cos(r.angle), sin = Math.sin(r.angle), hw = r.w/2, hh = r.h/2;
            return [{x:-hw*cos+hh*sin, y:-hw*sin-hh*cos}, {x:hw*cos+hh*sin, y:hw*sin-hh*cos}, {x:hw*cos-hh*sin, y:hw*sin+hh*cos}, {x:-hw*cos-hh*sin, y:-hw*sin+hh*cos}];
        }

        function updateUI() {
            const allY = rects.reduce((acc, r, i) => (r.type === 'car' ? acc.concat(i) : acc), []), selY = selectedIndices.filter(i => rects[i].type === 'car');
            ['Car', 'Spikes', 'Barricade'].forEach(c => {
                const btn = document.getElementById('btn' + c), type = c.toLowerCase();
                if (isShiftDown && selectedIndices.length > 0) {
                    btn.innerText = `↪ ${c.toLowerCase()}`; const protIdx = (allY.length > 0 && allY.length === selY.length && type !== 'car') ? selY[0] : -1;
                    btn.disabled = selectedIndices.filter(idx => idx !== protIdx && rects[idx].type !== type).length === 0;
                } else { btn.innerText = `✚ ${c.toLowerCase()}`; btn.disabled = rects.length >= MAX_RECTS; }
            });
            const sCount = selectedIndices.length, sYCount = selY.length;
            const isDeletingLastCar = (sYCount === allY.length && sCount === sYCount && sYCount === 1);
            document.getElementById('deleteBtn').disabled = sCount === 0 || isDeletingLastCar;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (isShiftDown && selectedIndices.length > 0) {
                ctx.beginPath(); ctx.strokeStyle = '#eee';
                for(let x=0; x<=700; x+=GRID_SIZE){ctx.moveTo(x,0);ctx.lineTo(x,450);}
                for(let y=0; y<=450; y+=GRID_SIZE){ctx.moveTo(0,y);ctx.lineTo(700,y);}
                ctx.stroke();
            }
            const queue = rects.map((r, i) => ({r, i})).sort((a, b) => (LAYER_PRIORITY[a.r.type] - LAYER_PRIORITY[b.r.type]) || (a.r.layer - b.r.layer));
            queue.forEach(item => {
                ctx.save(); ctx.translate(item.r.x, item.r.y); ctx.rotate(item.r.angle);
                ctx.drawImage(item.r.img, -item.r.w/2, -item.r.h/2, item.r.w, item.r.h);
                if (selectedIndices.includes(item.i)) { ctx.strokeStyle = '#007bff'; ctx.lineWidth = 3; ctx.strokeRect(-item.r.w/2, -item.r.h/2, item.r.w, item.r.h); }
                ctx.restore();
            });
            if (isBoxSelecting) { ctx.strokeStyle = '#007bff'; ctx.setLineDash([5,5]); ctx.strokeRect(boxStart.x, boxStart.y, boxEnd.x-boxStart.x, boxEnd.y-boxStart.y); ctx.setLineDash([]); }
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            rects.forEach(r => getLocalCorners(r).forEach(p => { minX=Math.min(minX,r.x+p.x); maxX=Math.max(maxX,r.x+p.x); minY=Math.min(minY,r.y+p.y); maxY=Math.max(maxY,r.y+p.y); }));
            if (rects.length > 0) {
                const mbb = { x: minX, y: minY, w: maxX-minX, h: maxY-minY, cx: minX + (maxX-minX)/2, cy: minY + (maxY-minY)/2 };
                ctx.setLineDash([5, 5]); ctx.strokeStyle = '#666'; ctx.strokeRect(mbb.x, mbb.y, mbb.w, mbb.h); ctx.setLineDash([]);
                if (rects.length > 1) { 
                    ctx.beginPath(); ctx.arc(mbb.cx, mbb.cy, 8, 0, Math.PI * 2);
                    ctx.fillStyle = 'white'; ctx.fill();
                    ctx.beginPath(); ctx.arc(mbb.cx, mbb.cy, 5, 0, Math.PI * 2); 
                    ctx.fillStyle = 'magenta'; ctx.fill(); 
                }
                updateOutput(mbb);
            }
            counterEl.innerText = `Room for ${MAX_RECTS - rects.length} more part(s)`;
        }

      function updateOutput(mbb) {
	     let t = `minRoadWidth = ${(mbb.w * LENGTH_SCALE).toFixed(2)}\n\n`;

	     rects.forEach((r, i) => {
                const ox = ((r.x - mbb.cx) * LENGTH_SCALE).toFixed(2);
                const oy = ((r.y - mbb.cy) * LENGTH_SCALE).toFixed(2);
                const rawDeg = (90 - r.angle * 180 / Math.PI) % 360;
		const disDeg = (r.type === 'car') ? rawDeg : (rawDeg + 90) % 360;
                const ref = (disDeg < 0) ? (360 + disDeg) : disDeg;

		type = 1;
		if (r.type == 'spikes')
		    type = 3;
		else if (r.type == 'barricade')
		    type = 2;

		const firstPad = (ox < 0) ? '' : ' ';
		const secondPad = (oy > 0) ? '' : ' ';
		 
                t += `part0${i+1} = ${type}, ${firstPad}${ox}, ${secondPad}${(-oy).toFixed(2)},  ${(ref / 360.0).toFixed(2)}\n`;
            });

            outputField.innerText = t;
        }

        function clearCanvas() { rects = []; selectedIndices = []; addRect('car'); updateUI(); draw(); canvas.focus(); }
    </script>
</body>
</html>
