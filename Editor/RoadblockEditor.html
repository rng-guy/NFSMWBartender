<!-- 
    HERE BE DRAGONS: Genuinely the WORST thing I've ever dared publish.

    I'd rather spend my time reversing game mechanics than refreshing my rusty
    JavaScript knowledge for a one-off tool, so I used Gemini to draft this mess.
    Nonetheless, it still took me hours of manual testing and un-fucking of the styling
    to get this to work as I had envisoned it. I might just rewrite once I get around
    to it, because I low-key loathe myself for having used generative AI for ANYTHING.

    After experiencing the "joys" of "vibecoding" (I hate that word SO much) for myself, 
    let me offer you a small piece of advice: Do NOT use generative AI for anything more
    complicated than basic HTML, CSS, and JS. While functional, this tool is still an 
    unmaintainable, div-laden mess that nobody should EVER attempt to refactor by hand. 
    I cannot even begin to imagine how annoying it would be to unfuck AI-generated C++
    or, god forbid, ASM by hand. My condolences to anyone whose employer mandates AI use.
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roadblock Editor</title>
    <link rel="icon" type="image/x-icon" href="Assets/Images/Icon.ico">
    <style>
        :root { --main-width: 700px; --caption-gap: 5px; }
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; gap: 20px; padding: 20px; background-color: #D9D9DB; }
        .workspace { display: flex; flex-direction: column; width: var(--main-width); gap: 10px; }
        .caption { font-weight: bold; font-size: 20px; color: #444; margin-bottom: var(--caption-gap); }
        .canvas-container { position: relative; width: var(--main-width); }
        #canvasCounter { position: absolute; top: 40px; left: 10px; background: rgba(0,0,0,0.6); color: #fcfcfcfc; padding: 4px 8px; border-radius: 4px; font-size: 11px; pointer-events: none; z-index: 10; }
        #canvasOverlay { position: absolute; bottom: 10px; right: 10px; font-size: 12px; color: #666; pointer-events: none; text-align: right; z-index: 5; transition: color 0.2s; }
        canvas { border: none; background-color: #fcfcfcfc; cursor: crosshair; box-shadow: 0 4px 10px rgba(0,0,0,0.1); display: block; width: var(--main-width); outline: none; }
        .bottom-controls { display: flex; justify-content: space-between; align-items: center; width: var(--main-width); margin-bottom: 25px; }
        .btn-group-left, .btn-group-right { display: flex; gap: 10px; }
        button { padding: 10px 15px; cursor: pointer; border-radius: 4px; border: 1px solid #ccc; background: #fcfcfcfc; font-size: 13px; }
        .btn-add { width: 105px; height: 40px; text-align: center; }
	    .btn-misc { height: 40px; text-align: center; }
        button:hover:not(:disabled) { background: #ececec; }
        button:disabled { cursor: not-allowed; opacity: 0.75; background: #ddd; border-color: #ccc; color: #999; }
        .output-container { display: flex; flex-direction: column; width: var(--main-width); }
        .output-wrapper { position: relative; width: var(--main-width); height: 180px; border: 1px solid #999; box-sizing: border-box; }
        #outputField { width: 100%; height: 100%; padding: 10px; border: none; box-sizing: border-box; white-space: pre-wrap; font-family: 'Courier New', monospace; font-size: 12px; overflow-y: auto; cursor: pointer; user-select: none; background: #242426; color: #DEDEDE; }
        #outputOverlay { position: absolute; bottom: 10px; right: 10px; font-size: 12px; color: #999999; pointer-events: none; }

        .modal-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 1000; justify-content: center; align-items: center;
        }
        .modal-content {
            background: #D9D9DB; padding: 15px; border-radius: 8px; width: 485px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3); display: flex; flex-direction: column; gap: 10px;
        }
        .modal-header { font-weight: bold; font-size: 20px; color: #444; margin-bottom: -5px; }
        .modal-textarea {
            width: 100%; height: 130px; font-family: 'Courier New', monospace; font-size: 12px;
            padding: 10px; box-sizing: border-box; resize: none; border: 1px solid #ccc;
            background: #242426; color: #DEDEDE;
            outline: none; /* No selection border */
        }
	.modal-textarea::placeholder { color: #DEDEDE4D }
        .modal-footer { display: flex; justify-content: flex-end; gap: 10px; }
    </style>
</head>
<body>

    <div class="workspace">
        <div class="canvas-container">
            <div class="caption">Roadblock</div>
            <div id="canvasCounter">Room for 5 more part(s)</div>
            <div id="canvasOverlay">Left-click to select. Scroll to rotate. Hold Shift to snap.</div>
            <canvas id="mainCanvas" width="700" height="450" tabindex="0"></canvas>
        </div>
        
        <div class="bottom-controls">
            <div class="btn-group-left">
                <button id="btnCar" class="btn-add" onclick="handleAction('car')">✚ car</button>
                <button id="btnSpikes" class="btn-add" onclick="handleAction('spikes')">✚ spikes</button>
                <button id="btnBarricade" class="btn-add" onclick="handleAction('barricade')">✚ barricade</button>
                <button id="btnImport" class="btn-misc" onclick="openImportModal()">import</button>
            </div>
            <div class="btn-group-right">
	            <button id="deleteBtn" class="btn-misc" onclick="deleteSelected()" disabled>remove selected</button>
                <button id="btnClear" class="btn-misc" onclick="clearCanvas()">clear</button>
            </div>
        </div>

        <div class="output-container">
            <div class="caption">Bartender settings</div>
            <div class="output-wrapper">
                <div id="outputField"></div>
                <div id="outputOverlay">Click to copy settings.</div>
            </div>
        </div>
    </div>

    <div id="importModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">Import from Bartender</div>
            <textarea id="importInput" class="modal-textarea" placeholder="part01 = typeID, {horizontal, vertical}Offset, orientation
part02 = typeID, ...





(roadblocks not from this editor may end up slightly misaligned)"></textarea>
            <div class="modal-footer">
                <button onclick="closeImportModal()">cancel</button>
                <button id="btnLoadImport" onclick="loadImportData()" disabled>apply</button>
            </div>
        </div>
    </div>

    <script>
        // Updated Constants
        const IMAGE_RENDER_SCALE = 0.25;
        const LENGTH_SCALE = 5.0 / (400 * IMAGE_RENDER_SCALE);
        
        const MAX_RECTS = 6;
        const GRID_SIZE = 10;
        const ROT_FINE = 5 * (Math.PI / 180), ROT_COARSE = 10 * (Math.PI / 180);
        const MOVE_FINE = 1, MOVE_COARSE = 10;
        const LAYER_PRIORITY = { barricade: 3, car: 2, spikes: 1 };
        const RECT_CONFIG = {
            car:       { src: 'Assets/Images/Car.webp' },
            spikes:    { src: 'Assets/Images/Spikes.webp' },
            barricade: { src: 'Assets/Images/Barricade.webp' }
        };
        const TYPE_MAP = { 1: 'car', 2: 'barricade', 3: 'spikes' };

        const images = {};
        let imagesLoaded = 0;
        const canvas = document.getElementById('mainCanvas'), ctx = canvas.getContext('2d');
        const outputField = document.getElementById('outputField'), outputOverlay = document.getElementById('outputOverlay'), counterEl = document.getElementById('canvasCounter');
        const canvasOverlay = document.getElementById('canvasOverlay');
        const modal = document.getElementById('importModal'), importInput = document.getElementById('importInput'), btnLoadImport = document.getElementById('btnLoadImport');
        
        let rects = [], selectedIndices = [], isDraggingGroup = false, isBoxSelecting = false;
        let boxStart = { x: 0, y: 0 }, boxEnd = { x: 0, y: 0 }, dragStartData = null, isShiftDown = false, selectionSnapshot = [], layerCounter = 0, clipboard = null;

        Object.keys(RECT_CONFIG).forEach(key => {
            const img = new Image(); img.src = RECT_CONFIG[key].src;
            img.onload = () => { if (++imagesLoaded === 3) initDefault(); };
            images[key] = img;
        });

        function initDefault() { addRect('car'); draw(); }

        function openImportModal() {
            modal.style.display = 'flex';
            importInput.value = '';
            btnLoadImport.disabled = true;
            importInput.focus();
        }

        function closeImportModal() {
            modal.style.display = 'none';
            canvas.focus();
        }

        modal.addEventListener('mousedown', (e) => {
            if (e.target === modal) closeImportModal();
        });

        function parseImportLines(text) {
            // Filter: Ignore lines not beginning with "part" (whitespace allowed)
            return text.split('\n')
                .map(l => l.trim())
                .filter(l => l.startsWith('part'));
        }

        importInput.addEventListener('input', () => {
            const lines = parseImportLines(importInput.value);
            
            let isValid = true;
            let hasCar = false;

            if (lines.length === 0 || lines.length > MAX_RECTS) isValid = false;
            else {
                const regex = /^\s*part(0[1-6])\s*=\s*([1-3])\s*,\s*(-?\d+(\.\d+)?)\s*,\s*(-?\d+(\.\d+)?)\s*,\s*(-?\d+(\.\d+)?)\s*$/;
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const match = line.match(regex);
                    
                    if (!match) { isValid = false; break; }
                    
                    // Strict Order check on FILTERED lines
                    const partNum = parseInt(match[1], 10);
                    if (partNum !== (i + 1)) { isValid = false; break; }
                    
                    if (parseInt(match[2]) === 1) hasCar = true;
                }
            }
            btnLoadImport.disabled = !(isValid && hasCar);
        });

        function loadImportData() {
            const lines = parseImportLines(importInput.value);
            const tempRects = [];
            const regex = /^\s*part(0[1-6])\s*=\s*([1-3])\s*,\s*(-?\d+(\.\d+)?)\s*,\s*(-?\d+(\.\d+)?)\s*,\s*(-?\d+(\.\d+)?)\s*$/;
            
            let localLayerCounter = 0;

            lines.forEach(line => {
                const match = line.match(regex);
                const typeCode = parseInt(match[2]);
                const offX = parseFloat(match[3]);
                const offY = parseFloat(match[5]);
                const deg = parseFloat(match[7]);

                const type = TYPE_MAP[typeCode];
                const img = images[type];
                
                // Convert angle from export format
                let degrees = deg * 360;
                let rawDeg = (type === 'car') ? degrees : (degrees - 90);
                let angleRad = (90 - rawDeg) * (Math.PI / 180);

                tempRects.push({
                    x: (offX / LENGTH_SCALE),
                    y: -(offY / LENGTH_SCALE),
                    w: img.width * IMAGE_RENDER_SCALE,
                    h: img.height * IMAGE_RENDER_SCALE,
                    img: img,
                    type: type,
                    angle: angleRad,
                    layer: ++localLayerCounter
                });
            });

            // Calculate MBB of the imported objects (Using Corners for visual centering)
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            tempRects.forEach(r => {
                const corners = getLocalCorners(r);
                corners.forEach(c => {
                    minX = Math.min(minX, r.x + c.x); maxX = Math.max(maxX, r.x + c.x);
                    minY = Math.min(minY, r.y + c.y); maxY = Math.max(maxY, r.y + c.y);
                });
            });

            const mbbCx = (minX + maxX) / 2;
            const mbbCy = (minY + maxY) / 2;
            const canvasCx = canvas.width / 2;
            const canvasCy = canvas.height / 2;

            // Shift to center on canvas
            rects = tempRects.map(r => ({
                ...r,
                x: r.x - mbbCx + canvasCx,
                y: r.y - mbbCy + canvasCy
            }));

            // Check for Out of Bounds after centering
            let isOutOfBounds = false;
            rects.forEach(r => {
                const corners = getLocalCorners(r);
                corners.forEach(c => {
                    const gx = r.x + c.x;
                    const gy = r.y + c.y;
                    if (gx < 0 || gx > canvas.width || gy < 0 || gy > canvas.height) {
                        isOutOfBounds = true;
                    }
                });
            });

            layerCounter = localLayerCounter;
            selectedIndices = [];
            closeImportModal();
            updateUI();
            draw();

            const defaultText = "Left-click to select. Scroll to rotate. Hold Shift to snap.";
	      
            if (isOutOfBounds) {
		canvasOverlay.innerHTML = 'Import <span style="color: #D61E00"><b>out of bounds</b></span>.';
              }
	      else
	      {
	        canvasOverlay.innerHTML = 'Import <span style="color: #00A34C"><b>successful</b></span>.';
              }

              setTimeout(() => { 
                    canvasOverlay.innerText = defaultText;
                    canvasOverlay.style.color = "#666";
              }, 4000);
	}

        document.addEventListener('mousedown', (e) => {
            if (e.target !== canvas && e.target.tagName !== 'BUTTON' && e.target !== outputField && !modal.contains(e.target) && e.target !== modal) { selectedIndices = []; updateUI(); draw(); }
        });

        outputField.addEventListener('click', () => {
            navigator.clipboard.writeText(outputField.innerText).then(() => {
                outputOverlay.innerHTML = 'Settings <span style="color: #DEB700"><b>copied</b></span>.';
                setTimeout(() => { outputOverlay.innerText = "Click to copy settings."; }, 4000);
            });
        });

        window.addEventListener('keydown', (e) => { 
            if (e.key === 'Escape') {
                if (modal.style.display === 'flex') { closeImportModal(); return; }
                if (document.activeElement === canvas) { selectedIndices = []; updateUI(); draw(); }
                return;
            }
            if (modal.style.display === 'flex') return;
            const isCanvasActive = (document.activeElement === canvas);
            if(e.key === 'Shift') { isShiftDown = true; updateUI(); draw(); }
            if(e.key === 'Delete' || e.key === 'Backspace') deleteSelected();
            
            if (e.ctrlKey && e.key.toLowerCase() === 'a' && isCanvasActive) { e.preventDefault(); selectedIndices = rects.map((_, i) => i); updateUI(); draw(); }
            if (e.ctrlKey && e.key.toLowerCase() === 'c' && selectedIndices.length > 0) clipboard = selectedIndices.map(i => ({...rects[i]}));
            if (e.ctrlKey && e.key.toLowerCase() === 'v' && clipboard) {
                if (rects.length + clipboard.length <= MAX_RECTS) {
                    const next = []; clipboard.forEach(c => {
                        layerCounter++; const nr = { ...c, x: c.x + 15, y: c.y + 15, layer: layerCounter };
                        if (!canExistAt(nr, nr.x, nr.y, nr.angle)) { nr.x = canvas.width/2; nr.y = canvas.height/2; }
                        rects.push(nr); next.push(rects.length - 1);
                    });
                    selectedIndices = next; updateUI(); draw();
                }
            }
            
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key) && selectedIndices.length > 0 && isCanvasActive) {
                e.preventDefault();
                const step = isShiftDown ? MOVE_COARSE : MOVE_FINE;
                let limit = step;
                selectedIndices.forEach(idx => {
                    const r = rects[idx], corners = getLocalCorners(r).map(c => ({ x: c.x + r.x, y: c.y + r.y }));
                    if (e.key === 'ArrowUp') limit = Math.min(limit, Math.min(...corners.map(c => c.y)));
                    if (e.key === 'ArrowDown') limit = Math.min(limit, canvas.height - Math.max(...corners.map(c => c.y)));
                    if (e.key === 'ArrowLeft') limit = Math.min(limit, Math.min(...corners.map(c => c.x)));
                    if (e.key === 'ArrowRight') limit = Math.min(limit, canvas.width - Math.max(...corners.map(c => c.x)));
                });
                if (limit > 0) {
                    selectedIndices.forEach(idx => {
                        if (e.key === 'ArrowUp') rects[idx].y -= limit;
                        if (e.key === 'ArrowDown') rects[idx].y += limit;
                        if (e.key === 'ArrowLeft') rects[idx].x -= limit;
                        if (e.key === 'ArrowRight') rects[idx].x += limit;
                    });
                    draw();
                }
            }
        });
        
        window.addEventListener('keyup', (e) => { if(e.key === 'Shift') { isShiftDown = false; updateUI(); draw(); }});
        
        canvas.addEventListener('mousedown', (e) => {
            canvas.focus(); const b = canvas.getBoundingClientRect(), mx = e.clientX - b.left, my = e.clientY - b.top;
            let hitIdx = -1;
            const sorted = rects.map((r, i) => ({r, i})).sort((a, b) => (LAYER_PRIORITY[b.r.type] - LAYER_PRIORITY[a.r.type]) || (b.r.layer - a.r.layer));
            for (let item of sorted) { if (isHit(item.r, mx, my)) { hitIdx = item.i; break; } }
            if (hitIdx !== -1) {
                if (!isShiftDown && !selectedIndices.includes(hitIdx)) selectedIndices = [hitIdx];
                else if (isShiftDown && !selectedIndices.includes(hitIdx)) selectedIndices.push(hitIdx);
                layerCounter++; rects[hitIdx].layer = layerCounter;
                isDraggingGroup = true;
                let minX = Math.min(...selectedIndices.map(i => rects[i].x)), minY = Math.min(...selectedIndices.map(i => rects[i].y));
                dragStartData = { groupMinX: minX, groupMinY: minY, mouseOffsetX: mx - minX, mouseOffsetY: my - minY, itemStarts: selectedIndices.map(idx => ({ idx, x: rects[idx].x, y: rects[idx].y })) };
            } else {
                if (!isShiftDown) selectedIndices = [];
                selectionSnapshot = [...selectedIndices]; isBoxSelecting = true; boxStart = { x: mx, y: my }; boxEnd = { x: mx, y: my };
            }
            updateUI(); draw();
        });

        window.addEventListener('mousemove', (e) => {
            const b = canvas.getBoundingClientRect(), mx = e.clientX - b.left, my = e.clientY - b.top;
            if (isDraggingGroup && dragStartData) {
                let tx = mx - dragStartData.mouseOffsetX, ty = my - dragStartData.mouseOffsetY;
                if (isShiftDown) { tx = Math.round(tx/GRID_SIZE)*GRID_SIZE; ty = Math.round(ty/GRID_SIZE)*GRID_SIZE; }
                const dx = tx - dragStartData.groupMinX, dy = ty - dragStartData.groupMinY;
                const props = dragStartData.itemStarts.map(p => ({ idx: p.idx, x: p.x + dx, y: p.y + dy }));
                let sL = 0, sR = 0, sU = 0, sD = 0;
                props.forEach(p => {
                    const corners = getLocalCorners(rects[p.idx]), minLX = Math.min(...corners.map(c => c.x)), maxLX = Math.max(...corners.map(c => c.x)), minLY = Math.min(...corners.map(c => c.y)), maxLY = Math.max(...corners.map(c => c.y));
                    if (p.x + minLX < 0) sR = Math.max(sR, -(p.x + minLX));
                    if (p.x + maxLX > canvas.width) sL = Math.min(sL, canvas.width - (p.x + maxLX));
                    if (p.y + minLY < 0) sD = Math.max(sD, -(p.y + minLY));
                    if (p.y + maxLY > canvas.height) sU = Math.min(sU, canvas.height - (p.y + maxLY));
                });
                props.forEach(p => { rects[p.idx].x = p.x + sR + sL; rects[p.idx].y = p.y + sD + sU; });
            } else if (isBoxSelecting) {
                boxEnd = { x: mx, y: my }; const xMin = Math.min(boxStart.x, boxEnd.x), xMax = Math.max(boxStart.x, boxEnd.x), yMin = Math.min(boxStart.y, boxEnd.y), yMax = Math.max(boxStart.y, boxEnd.y);
                const inBox = rects.map((r, i) => (r.x >= xMin && r.x <= xMax && r.y >= yMin && r.y <= yMax ? i : -1)).filter(i => i !== -1);
                selectedIndices = Array.from(new Set([...selectionSnapshot, ...inBox])); updateUI();
            }
            draw();
        });

        window.addEventListener('mouseup', () => { isDraggingGroup = false; isBoxSelecting = false; draw(); });

        canvas.addEventListener('wheel', (e) => {
            if (selectedIndices.length > 0) {
                e.preventDefault(); 
                const step = isShiftDown ? ROT_COARSE : ROT_FINE;
                const direction = e.deltaY > 0 ? 1 : -1;
                
                // Rotation Snapping Logic
                if (selectedIndices.every(idx => {
                    const r = rects[idx];
                    let newAngle = r.angle + (direction * step);
                    // Snap to integer multiple of step
                    newAngle = Math.round(newAngle / step) * step;
                    return canExistAt(r, r.x, r.y, newAngle);
                })) {
                    selectedIndices.forEach(idx => {
                        let newAngle = rects[idx].angle + (direction * step);
                        rects[idx].angle = Math.round(newAngle / step) * step;
                    });
                    draw();
                }
            }
        }, { passive: false });

        function canExistAt(r, nx, ny, na) {
            const cos = Math.cos(na), sin = Math.sin(na), hw = r.w/2, hh = r.h/2;
            const corners = [{x:-hw*cos+hh*sin, y:-hw*sin-hh*cos}, {x:hw*cos+hh*sin, y:hw*sin-hh*cos}, {x:hw*cos-hh*sin, y:hw*sin+hh*cos}, {x:-hw*cos-hh*sin, y:-hw*sin+hh*cos}];
            return corners.every(c => (nx + c.x >= 0 && nx + c.x <= canvas.width && ny + c.y >= 0 && ny + c.y <= canvas.height));
        }

        function handleAction(type) {
            if (isShiftDown && selectedIndices.length > 0) {
                const allY = rects.reduce((acc, r, i) => (r.type === 'car' ? acc.concat(i) : acc), []);
                const selY = selectedIndices.filter(i => rects[i].type === 'car');
                const protIdx = (allY.length > 0 && allY.length === selY.length && type !== 'car') ? selY[0] : -1;
                selectedIndices.forEach(idx => { if (idx !== protIdx) transformRect(idx, type); });
            } else addRect(type);
            updateUI(); draw(); canvas.focus();
        }

        function addRect(type) {
            if (rects.length < MAX_RECTS) {
                const img = images[type]; layerCounter++;
                rects.push({ x: canvas.width/2, y: canvas.height/2, w: img.width*IMAGE_RENDER_SCALE, h: img.height*IMAGE_RENDER_SCALE, img, type, angle: 0, layer: layerCounter });
                selectedIndices = [rects.length - 1];
            }
        }

        function transformRect(idx, newType) {
            const r = rects[idx], img = images[newType];
            r.type = newType; r.img = img; r.w = img.width*IMAGE_RENDER_SCALE; r.h = img.height*IMAGE_RENDER_SCALE;
            if (!canExistAt(r, r.x, r.y, r.angle)) { r.x = canvas.width/2; r.y = canvas.height/2; }
        }

        function deleteSelected() {
            if (selectedIndices.length === 0) return;
            const allY = rects.reduce((acc, r, i) => (r.type === 'car' ? acc.concat(i) : acc), []);
            const selY = selectedIndices.filter(i => rects[i].type === 'car');
            let safe = [...selectedIndices].sort((a,b) => b-a);
            if (allY.length > 0 && allY.length === selY.length) safe = safe.filter(i => i !== selY[0]);
            safe.forEach(i => rects.splice(i, 1));
            selectedIndices = rects.length > 0 ? [rects.length - 1] : [];
            updateUI(); draw(); canvas.focus();
        }

        function isHit(r, mx, my) {
            const cos = Math.cos(-r.angle), sin = Math.sin(-r.angle), dx = mx-r.x, dy = my-r.y;
            const rx = dx*cos-dy*sin, ry = dx*sin+dy*cos;
            return (rx >= -r.w/2 && rx <= r.w/2 && ry >= -r.h/2 && ry <= r.h/2);
        }

        function getLocalCorners(r) {
            const cos = Math.cos(r.angle), sin = Math.sin(r.angle), hw = r.w/2, hh = r.h/2;
            return [{x:-hw*cos+hh*sin, y:-hw*sin-hh*cos}, {x:hw*cos+hh*sin, y:hw*sin-hh*cos}, {x:hw*cos-hh*sin, y:hw*sin+hh*cos}, {x:-hw*cos-hh*sin, y:-hw*sin+hh*cos}];
        }

        function updateUI() {
            const allY = rects.reduce((acc, r, i) => (r.type === 'car' ? acc.concat(i) : acc), []), selY = selectedIndices.filter(i => rects[i].type === 'car');
            ['Car', 'Spikes', 'Barricade'].forEach(c => {
                const btn = document.getElementById('btn' + c), type = c.toLowerCase();
                if (isShiftDown && selectedIndices.length > 0) {
                    btn.innerText = `↪ ${c.toLowerCase()}`; const protIdx = (allY.length > 0 && allY.length === selY.length && type !== 'car') ? selY[0] : -1;
                    btn.disabled = selectedIndices.filter(idx => idx !== protIdx && rects[idx].type !== type).length === 0;
                } else { btn.innerText = `✚ ${c.toLowerCase()}`; btn.disabled = rects.length >= MAX_RECTS; }
            });
            const sCount = selectedIndices.length, sYCount = selY.length;
            const isDeletingLastCar = (sYCount === allY.length && sCount === sYCount && sYCount === 1);
            document.getElementById('deleteBtn').disabled = sCount === 0 || isDeletingLastCar;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (isShiftDown && selectedIndices.length > 0) {
                ctx.beginPath(); ctx.strokeStyle = '#eee';
                for(let x=0; x<=700; x+=GRID_SIZE){ctx.moveTo(x,0);ctx.lineTo(x,450);}
                for(let y=0; y<=450; y+=GRID_SIZE){ctx.moveTo(0,y);ctx.lineTo(700,y);}
                ctx.stroke();
            }
            const queue = rects.map((r, i) => ({r, i})).sort((a, b) => (LAYER_PRIORITY[a.r.type] - LAYER_PRIORITY[b.r.type]) || (a.r.layer - b.r.layer));
            queue.forEach(item => {
                ctx.save(); ctx.translate(item.r.x, item.r.y); ctx.rotate(item.r.angle);
                ctx.drawImage(item.r.img, -item.r.w/2, -item.r.h/2, item.r.w, item.r.h);
                if (selectedIndices.includes(item.i)) { ctx.strokeStyle = '#007bff'; ctx.lineWidth = 3; ctx.strokeRect(-item.r.w/2, -item.r.h/2, item.r.w, item.r.h); }
                ctx.restore();
            });
            if (isBoxSelecting) { ctx.strokeStyle = '#007bff'; ctx.setLineDash([5,5]); ctx.strokeRect(boxStart.x, boxStart.y, boxEnd.x-boxStart.x, boxEnd.y-boxStart.y); ctx.setLineDash([]); }
            
            // Full-extent MBB Calculation (Corners included)
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            rects.forEach(r => {
                const corners = getLocalCorners(r);
                corners.forEach(p => {
                    minX = Math.min(minX, r.x + p.x);
                    maxX = Math.max(maxX, r.x + p.x);
                    minY = Math.min(minY, r.y + p.y);
                    maxY = Math.max(maxY, r.y + p.y);
                });
            });

            if (rects.length > 0) {
                const mbb = { x: minX, y: minY, w: maxX-minX, h: maxY-minY, cx: minX + (maxX-minX)/2, cy: minY + (maxY-minY)/2 };
                ctx.setLineDash([5, 5]); ctx.strokeStyle = '#666'; ctx.strokeRect(mbb.x, mbb.y, mbb.w, mbb.h); ctx.setLineDash([]);
                if (rects.length > 1) { 
                    ctx.beginPath(); ctx.arc(mbb.cx, mbb.cy, 8, 0, Math.PI * 2);
                    ctx.fillStyle = 'white'; ctx.fill();
                    ctx.beginPath(); ctx.arc(mbb.cx, mbb.cy, 5, 0, Math.PI * 2); 
                    ctx.fillStyle = 'magenta'; ctx.fill(); 
                }
                updateOutput(mbb);
            }
            counterEl.innerText = `Room for ${MAX_RECTS - rects.length} more part(s)`;
        }

      function updateOutput(mbb) {

             const strPad = (num, places) => String(num).padStart(places, ' ');
				    
	     const width = (mbb.w * LENGTH_SCALE).toFixed(2);
	  let t = `minRoadWidth = ${width}\n\n`;

	  let firstWidth = 0;
	  let secondWidth = 0;

	  rects.forEach((r, i) => {
	      const ox = ((r.x - mbb.cx) * LENGTH_SCALE).toFixed(2);
              const oy = ((mbb.cy - r.y) * LENGTH_SCALE).toFixed(2);

	      if (ox.length > firstWidth) firstWidth = ox.length;
	      if (oy.length > secondWidth) secondWidth = oy.length;
	  });

	     rects.forEach((r, i) => {
                const ox = ((r.x - mbb.cx) * LENGTH_SCALE).toFixed(2);
                const oy = ((mbb.cy - r.y) * LENGTH_SCALE).toFixed(2);
                const rawDeg = (90 - r.angle * 180 / Math.PI) % 360;
		const disDeg = (r.type === 'car') ? rawDeg : (rawDeg + 90) % 360;
                const ref = (disDeg < 0) ? (360 + disDeg) : disDeg;

                let type = 1;
                if (r.type == 'spikes') type = 3;
                else if (r.type == 'barricade') type = 2;			      
                
                 t += `part0${i+1} = ${type}, ${strPad(ox, firstWidth)}, ${strPad(oy, secondWidth)}, ${(ref / 360.0).toFixed(3)}\n`;
            });

            outputField.innerText = t;
        }

        function clearCanvas() { rects = []; selectedIndices = []; addRect('car'); updateUI(); draw(); canvas.focus(); }
    </script>
</body>
</html>
